<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>Rust Primer</title>

        <link rel="stylesheet" href="reveal.js-4.1.2/dist/reveal.css">
        <link rel="stylesheet" href="reveal.js-4.1.2/dist/theme/black.css">

        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="reveal.js-4.1.2/plugin/highlight/zenburn.css">

        <style type="text/css">
            .reveal span>code, .inline-code code {
                line-height: 1.2em;
                font-size: 0.55em;
                padding: 5px;
                width: 100%;
                display: inline;
            }
        </style>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h2>Rust Primer</h2>
                    <h3></h3>
                </section>
                <section>
                    <h2>What is Rust?</h2>
                    <p>
                        <ul>
                            <li>Systems programming language</li>
                            <li>Strong static typing</li>
                            <li>Guaranteed memory safety<span style="color: red;">*</span></li>
                            <li>No undefined behavior<span style="color: red;">*</span></li>
                        </ul>
                    </p>
                    <p style="text-align: right;" class="fragment">
                        <span style="color: red;">*</span>except when using ðŸ‘»<code class="rust">unsafe</code>ðŸ‘»
                    </p>
                    <img src="rust-logo-white.svg" style="border: 0; background: 0; box-shadow: unset; margin: auto 0;">
                    <aside class="notes" data-markdown>
                        * No dynamic memory management, run-time
                        * Namespacing, sane file inclusion, lambdas
                        * Package manager
                    </aside>
                </section>
                <section>
                    <h2>More information</h2>
                    <p>
                        <ul>
                            <li>Installing: <a href="https://www.rust-lang.org/tools/install">rust-lang.org/tools/install</a></li>
                            <li>Learn: <a href="https://www.rust-lang.org/learn">rust-lang.org/learn</a>
                                <ul>
                                    <li>Rust book: <a href="https://doc.rust-lang.org/book/">doc.rust-lang.org/book</a></li>
                                    <li>Standard library: <a href="https://doc.rust-lang.org/std"/>doc.rust-lang.org/std</a></li>
                                </ul>
                            </li>
                            <li>Playground: <a href="https://play.rust-lang.org/">play.rust-lang.org</a></li>
                            <li>These slides: <a href="https://hugwijst.github.io/rust-primer/">hugwijst.github.io/rust-primer</a></li>
                        </ul>
                    </p>
                </section>
                <section>
                    <h2>Using Cargo</h2>
                    <p>
                        <ul>
                            <li><code>cargo init</code></li>
                            <li><code>cargo check</code></li>
                            <li><code>cargo build</code></li>
                            <li><code>cargo run</code></li>
                            <li><code>cargo test</code></li>
                        </ul>
                    </p>
                    <aside class="notes" data-markdown>
                        * `init` is binary by default, `--lib` for library
                        * Cargo will automatically rebuild if needed (run/test)
                        * normal build is debug, `--release` for release builds
                    </aside>
                </section>
                <section>
                    <h2>Contents</h2>
                    <ul>
                        <li>Primitive types</li>
                        <li>Ownership</li>
                        <li>Control flow</li>
                        <li>Code organization</li>
                        <li>Custom data types</li>
                        <li>Error handling</li>
                        <li>Heap allocated data</li>
                    </ul>
                </section>
                <section>
                    <h2>Primitive types</h2>
                    <ul class="rust">
                        <li><span class="rust"><code>bool</code> (<code>true</code>, <code>false</code>)</span></li>
                        <li><span class="rust">
                            <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>
                            (<code>12u8</code>, <code>b'a'</code>, <code>65_536u32</code>)
                        </span></li>
                        <li><span class="rust">
                            <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>
                            (<code>0x1EEFi16</code>, <code>-3_000_000_000i64</code>)
                        </span></li>
                        <li><span class="rust">
                            <code>usize</code>, <code>isize</code> (<code>15usize</code>, <code>-12isize</code>)
                        </span></li>
                        <li><span class="rust">
                            <code>f32</code>, <code>f64</code> (<code>1e24f32</code>, <code>0.24f64</code>)
                        </span></li>
                        <li><span class="rust">
                            <code>char</code> (<code>'a'</code>, <code>'ðŸ’¡'</code>)
                        </span></li>
                    </ul>
                    <aside class="notes" data-markdown>
                        * note suffix
                        * `b'a'` is an unsigned byte
                        * `usize`, `isize`: size of a native word on the architecture
                        * `_` to help readability of numbers
                        * `char` is a **UTF-8** character, size: 4 bytes!
                    </aside>
                </section>
                <section>
                    <h2>Assignment</h2>
                    <pre><code class="rust" data-line-numbers data-trim>
                        fn main() {
                            let x: u32 = 24u32; // fully explicit
                            let x = 16u8;       // infered type of `x`
                            let x: f32 = 12.;   // infered type of `12.`
                            let x = 42;         // defaults to isize
                            let x = 42u;        // or usize when unsigned
                            let x = 42.;        // or f64 when float

                            let x;
                            x = 15;             // deferred assignment
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Note: shadowing of local variables
                    </aside>
                </section>
                <section>
                    <h2>Casting</h2>
                    <pre><code class="rust" data-line-numbers data-trim>
                        fn main() {
                            let x: u32 = 12u8;          //< fails to compile!
                            //           ^^^^ expected u32, found u8
                            let x: u32 = 12u64;         //< fails to compile!
                            //           ^^^^^ expected u32, found u64
                            let x: u32 = 12u64 as u32;  // x == 12

                            let x = 400u16 as u8;       // x == 144
                            let x = -3i8 as u8;         // x == 253
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * No implicit conversions or promotions
                        * Negative numbers are interpreted as 2s-complement when converted
                    </aside>
                </section>
                <section>
                    <h2>Mutability</h2>
                    <pre><code class="rust" data-line-numbers data-trim>
                        fn main() {
                            let x = 41;
                            x = 42;         //< fails to compile!
                        //  ^^^^^^ cannot assign twice to immutable variable
                            let x = 42;

                            let mut x = 41;
                            x = 42;
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Shadowing preferred for non-mutable data
                    </aside>
                </section>
                <section>
                    <h2>References</h2>
                    <ul>
                        <li>References and mutability</li>
                        <li>Ownership</li>
                    </ul>
                </section>
                <section>
                    <h2>References</h2>
                    <pre style="position:absolute; width: 100%"><code class="rust" data-noescape data-line-numbers data-trim style="max-height: 600px;">
                        fn main() {
                            let x = 41u32;
                            let r: &amp;u32 = &amp;x;

                            assert!(x == 41);
                            assert!(*r == 41);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * First use of `assert!`
                    </aside>
                </section>
                <section>
                    <h2>Uninitialized References</h2>
                    <pre><code class="rust" data-line-numbers data-trim>
                        fn main() {
                            let r: &amp;u32;
                            assert!(*r == 4); //< fails to compile!
                            //      ^^ use of possibly uninitialized `*r`
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                    </aside>
                </section>
                <section>
                    <h2>Mutable References</h2>
                    <pre style="position:absolute; width: 100%"><code class="rust" data-line-numbers data-noescape data-trim style="max-height: 600px;">
                        fn main() {
                            let x = 41u32;
                            let r: &amp;u32 = &amp;x;
                            assert!(*r == 41);
                            
                            <span class="fragment" data-fragment-index="2">let y = 42;</span>
                        <span class="fragment" data-fragment-index="2">    r = &amp;y;</span><span class="fragment" data-fragment-index="3">  //< fails to compile!</span>
                        <span class="fragment" data-fragment-index="3">//  ^^^^^^ cannot assign twice to immutable variable</span>

                        <span class="fragment" data-fragment-index="4">    let mut s = &amp;y;    assert!(*s == 42);</span>
                        <span class="fragment" data-fragment-index="4">    s = &amp;x;            assert!(*s == 41);</span>
                        <span class="fragment" data-fragment-index="5">    *s = 4;</span><span class="fragment" data-fragment-index="6"> //< fails to compile!</span>
                        <span class="fragment" data-fragment-index="6">//  ^^^^^^ `s` is a `&` reference, so the data it refers to</span>
                        <span class="fragment" data-fragment-index="6">//         cannot be written</span>
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                    </aside>
                </section>
                <section>
                    <h2>Reference To Mutable</h2>
                    <pre><code class="rust" data-line-numbers data-noescape data-trim>
                        fn main() {
                            let mut x = 41;
                            let r: &amp;mut u32 = &amp;mut x;
                            assert!(*r == 41);
                            
                            *r = 42;
                            assert!(*r == 42);
                            assert!(x == 42);

                            <span class="fragment" data-fragment-index="2">let x = 41u32;</span>
                            <span class="fragment" data-fragment-index="2">let r: &amp;mut u32 = &amp;mut x; //< fails to compile!</span>
                            <span class="fragment" data-fragment-index="2">//                ^^^^^^ cannot borrow as mutable</span>
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                    </aside>
                </section>
                <section>
                    <h2>Ownership 1</h2>
                    <pre><code class="rust" data-line-numbers data-noescape data-trim>
                        fn main() {
                            let mut x = 41;

                            let r = &amp;x;
                            <span class="fragment" data-fragment-index="3">//      -- immutable borrow occurs here</span>
                            let r_mut = &amp;mut x;
                            <span class="fragment" data-fragment-index="3">//          ^^^^^^ mutable borrow occurs here</span>
                            assert!(*r == *r_mut);<span class="fragment" data-fragment-index="2"> //< fails to compile!</span>
                            <span class="fragment" data-fragment-index="3">//      -- immutable borrow later used here</span>
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        Either many immutable borrows *OR* one mutable borrow.
                    </aside>
                </section>
                <section>
                    <h2>Ownership 2</h2>
                    <pre><code class="rust" data-line-numbers data-noescape data-trim>
                        fn main() {
                            let mut x = 41;

                            let r_mut = &amp;mut x;
                            <span class="fragment" data-fragment-index="2">//          ------ borrow of `x` occurs here</span>
                            assert!(x == *r_mut); //< fails to compile!
                            <span class="fragment" data-fragment-index="2">//      ^    ------ borrow later used here</span>
                            <span class="fragment" data-fragment-index="2">//      |</span>
                            <span class="fragment" data-fragment-index="2">//      use of borrowed `x`</span>
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        No access to borrowed variables.
                    </aside>
                </section>
                <section>
                    <h2>Ownership 3</h2>
                    <pre><code class="rust" data-line-numbers data-noescape data-trim>
                        fn main() {
                            let mut x = 41;

                            let r = &amp;x;
                        <span class="fragment" data-fragment-index="2">//          -- borrow of `x` occurs here</span>
                            assert!(x == *r);

                            x = 42;
                        <span class="fragment" data-fragment-index="2">//  ^^^^^^ assignment to borrowed `x` occurs here</span>
                            assert!(x == *r); //< fails to compile!
                        <span class="fragment" data-fragment-index="2">//               -- borrow later used here</span>
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        No access to borrowed variables.
                    </aside>
                </section>
                <section>
                    <h2>Sequences</h2>
                    <ul>
                        <li>Arrays</li>
                        <li>Slices</li>
                        <li>Strings</li>
                    </ul>
                </section>
                <section>
                    <h2>Arrays</h2>
                    <pre><code class="rust" data-line-numbers data-trim>
                        fn main() {
                            let array: [i32; 3] = [1, 4, -3];

                            assert!(array[0] == 1);
                            assert!(array[3] == 4); //< Fails to compile!

                            let n = 3;
                            assert!(array[n] == 4); //< Panics!

                            let all_5s = [5u8; 5];
                            assert!(all_5s == [5, 5, 5, 5, 5]);
                            assert!(all_5s.len() == 5);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Array is fixed size.
                        * In example array stored on stack.
                        * Needs to be fully initialized!
                        * Panics on out-of-bounds index access.
                    </aside>
                </section>
                <section>
                    <h2>Slices</h2>
                    <pre><code class="rust" data-line-numbers data-trim style="max-height: 100%">
                        fn main() {
                            let arr1: [i32; 3] = [1, 4, -3];

                            let mut arr_ref: &amp;[i32] = &amp;arr1;
                            assert!(arr_ref[0] == 1);
                            assert!(arr_ref[3] == 4); //< Panics!

                            let arr2 = [1, 2, 3, 4, 5];
                            arr_ref = &amp;arr2;
                            assert!(*arr_ref == [1, 2, 3, 4, 5]);

                            arr_ref = &amp;arr_ref[2..];
                            assert!(arr_ref == [3, 4, 5]);
                            assert!(arr_ref.len() == 3);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Slice: reference to contiguous data **and** length
                        * Panics on out-of-bounds index access.
                        * Can create and store subslice with range.
                        * `*` can often be elided.
                    </aside>
                </section>
                <section>
                    <h2>String slices</h2>
                    <pre style="width: initial;"><code class="rust" data-line-numbers data-trim>
                        fn main() {
                            let hello_world: &str = "Hello World ðŸ‘‹!";

                            assert!(hello_world.len() == 17); // in bytes!
                            assert!(hello_world.chars().count() == 14);

                            assert!(&hello_world[..5] == "Hello");
                            assert!(&hello_world[..12] == "Hello World ");
                            assert!(&hello_world[..13] == "Hello World "); //< Panics!

                            assert!("".len() == 0);
                            assert!("\0".len() == 1);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Strings are complicated
                        * `&str` points to a UTF-8 string
                        * No null-termination
                    </aside>
                </section>
                <section>
                    <h2>Contents</h2>
                    <ul>
                        <li style="color: grey;">Primitive types</li>
                        <li style="color: grey;">Ownership</li>
                        <li>Control flow</li>
                        <li>Code organization</li>
                        <li>Custom data types</li>
                        <li>Error handling</li>
                        <li>Heap allocated data</li>
                    </ul>
                </section>
                <section data-markdown class="inline-code">
                    <textarea data-template>
                        ## Operators

                        * numeric (`+`, `-`, `*`, `/`, `%`)
                        * bitwise (`|`, `&`, `^`, `<<`, `>>`)
                        * comparison (`==`, `!=`, `>`, `<`, `>=`, `<=`)
                        * logical (`||`, `&&`)
                        * number negation (`-`)
                        * boolean negation (`!`)
                        * number bitwise negation (`!`) <span class="fragment" data-fragment-index="1">ðŸš¨</span>
                        * compound assignment (`+=`, `|=`, etc.)
                        * **NO**: increment/decrement (`++`, `--`)

                        notes:
                        * overflow and underflow well defined, 2s-complement in release
                        * logical operations only on `bool`
                        * bitwise negation is non-C
                    </textarea>
                </section>
                <section>
                    <h2>Control Flow</h2>
                    <ul>
                        <li>If</li>
                        <li>Loops</li>
                        <li>Lambdas and Closures</li>
                        <li>Iterators</li>
                    </ul>
                </section>
                <section>
                    <h2>Control flow: if</h2>
                    <div class="fragment fade-out" data-fragment-index="1"><pre style="position:absolute;width:100%"><code class="rust" data-line-numbers data-trim>
                        fn min(a: usize, b: usize) -> usize {
                            let ret;
                            if a < b {
                                ret = a;
                            } else {
                                ret = b;
                            }
                            return ret;
                        }

                        fn main() {
                            assert!(min(5,8) == 5);
                        }
                    </code></pre></div>
                    <div class="fragment current-visible" data-fragment-index="1"><pre style="position:absolute;width:100%"><code class="rust" data-line-numbers data-trim>
                        fn min(a: usize, b: usize) -> usize {
                            let ret;
                            if a < b {
                                ret = a;
                            } else {
                                ret = b;
                            }
                            ret
                        }

                        fn main() {
                            assert!(min(5,8) == 5);
                        }
                    </code></pre></div>
                    <div class="fragment current-visible" data-fragment-index="2"><pre style="position:absolute;width:100%"><code class="rust" data-line-numbers data-trim data-noescape>
                        fn min(a: usize, b: usize) -> usize {
                            let ret <mark>=</mark> if a < b { a } else { b }<mark>;</mark>
                            ret
                        }

                        fn main() {
                            assert!(min(5,8) == 5);
                        }
                    </code></pre></div>
                    <div class="fragment fade-in" data-fragment-index="3"><pre style="position:absolute;width:100%"><code class="rust" data-line-numbers data-trim data-noescape>
                        fn min(a: usize, b: usize) -> usize {
                            if a < b { a } else { b }
                        }

                        fn main() {
                            assert!(min(5,8) == 5);
                        }
                    </code></pre></div>
                    <aside class="notes" data-markdown>
                        * first non-`main` function!
                        * No braces around condition expression
                        * `if` is an expression, not a statement
                    </aside>
                </section>
                <section>
                    <h2>Control flow: loop</h2>
                    <pre><code class="rust" data-line-numbers data-trim style="max-height: 450px;">
                        fn main() {
                            let start = 3;
                            let mut x = start;

                            while x > 0 {
                                println!("down = {}", x);
                                x -= 1;
                            }

                            loop {
                                println!("up = {}", x);
                                x += 1;

                                if x >= start { break }
                            }
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * First `println!`!
                        * No do-while!
                    </aside>
                </section>
                <section>
                    <h2>Control flow: for-loop</h2>
                    <pre><code class="rust" data-line-numbers data-trim style="max-height: 450px;">
                        fn main() {
                            let mut x = 0;

                            for i in 1..5 {
                                x += i;
                            }

                            assert!(x == 10);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * `1..5` is a range, 1-inclusive and 5-exclusive
                        * `for` iterates over een iterator, a range is an iterator
                    </aside>
                </section>
                <section>
                    <h2>Lambdas & Closures</h2>
                    <pre><code class="rust" data-line-numbers data-trim style="max-height: 500px;">
                        fn min(a: usize, b: usize) -> usize {
                            if a < b { a } else { b }
                        }

                        fn main() {
                            fn local_min(a: usize, b: usize) -> usize {
                                if a < b { a } else { b }
                            }
                            assert!(min(1, 2) == 1);
                            assert!(local_min(1, 2) == 1);

                            let lambda_min = |a, b| if a < b { a } else { b };
                            assert!(lambda_min(5, 8) == 5);

                            let a = 4;
                            let min_of_a_and = |b| if a < b { a } else { b };
                            assert!(min_of_a_and(8) == 4);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Contrived :)
                        * Local functions
                        * Closure captures environment
                        * Closure useful when passed to function, see later
                    </aside>
                </section>
                <section>
                    <h2>Iterator: filter + map</h2>
                    <pre><code class="rust" data-line-numbers data-trim style="max-height: 450px;">
                        fn main() {
                            let mut s = 0;
                            for i in (1..10).filter(|x| x % 2 == 0) {
                                s += i; // i <- [2, 4, 6, 8]
                            }
                            assert!(s == 20);

                            s = 0;
                            for i in (1..5).map(|x| x * 3 + 1)  {
                                s += i; // i <- [4, 7, 10, 13]
                            }
                            assert!(s == 34);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * explain `filter` and `map` methods
                    </aside>
                </section>
                <section>
                    <h2>Contents</h2>
                    <ul>
                        <li style="color: grey;">Primitive types</li>
                        <li style="color: grey;">Ownership</li>
                        <li style="color: grey;">Control flow</li>
                        <li>Code organization</li>
                        <li>Custom data types</li>
                        <li>Error handling</li>
                        <li>Heap allocated data</li>
                    </ul>
                </section>
                <section>
                    <h2>Code organization</h2>
                    <ul>
                        <li>Modules</li>
                        <li>Visibility</li>
                        <li>Multi-file crate</li>
                    </ul>
                </section>
                <section>
                    <h2>Modules</h2>
                    <pre><code class="rust" data-line-numbers data-trim style="max-height: 450px;">
                        mod math {
                            pub fn sum_u32(a: u32, b: u32) -> u32 {
                                a + b
                            }

                            pub fn sum_f32(a: f32, b: f32) -> f32 {
                                a + b
                            }
                        }

                        fn main() {
                            assert!(math::sum_u32(15, 5) == 20);

                            use math::sum_f32;
                            assert!(sum_f32(1.5, 20.5) == 22.0);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * `mod` used for organizing code in different name spaces
                        * import into current name space using `use`
                    </aside>
                </section>
                <section>
                    <h2>Visibility</h2>
                    <pre style="width: initial"><code class="rust" data-line-numbers data-trim style="max-height: 560px;">
                        mod math {
                            pub mod u32 {
                                pub fn sum(a: u32, b: u32) -> u32 { helper(a, b) }
                                fn helper(a: u32, b: u32) -> u32 { a + b }
                            }

                            pub mod f32 {
                                pub fn sum(a: f32, b: f32) -> f32 { a + b }
                            }
                        }

                        fn main() {
                            assert!(math::u32::sum(15, 5) == 20);

                            use math::f32::sum as sum_f32;
                            assert!(sum_f32(1.5, 20.5) == 22.0);

                            math::u32::helper(1, 2); //< fails to compile!
                        //             ^^^^^^ function `helper` is private
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                    </aside>
                </section>
                <section>
                    <h2>Exporting</h2>
                    <pre style="width: initial"><code class="rust" data-line-numbers data-trim style="max-height: 550px;">
                        mod math {
                            mod u32 {
                                pub fn sum(a: u32, b: u32) -> u32 { helper(a, b) }
                                fn helper(a: u32, b: u32) -> u32 { a + b }
                            }

                            pub use self::u32::sum as sum_u32;
                            use self::u32::sum as sum_u32_priv;
                        }

                        fn main() {
                            assert!(math::sum_u32(15, 5) == 20);

                            math::sum_u32_priv(1, 2); //< fails to compile!
                        //        ^^^^^^^^^^^^ function `sum_u32_priv` is private
                            math::u32::sum(1, 2); //< fails to compile!
                        //        ^^^ module `u32` is private
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * `pub use` re-exports publicly 
                    </aside>
                </section>
                <section>
                    <h2>Multi-file crate</h2>
                    <pre style="width: initial">math.rs:<code class="rust" data-line-numbers data-trim style="max-height: 550px;">
                        mod u32 {
                            pub fn sum(a: u32, b: u32) -> u32 { helper(a, b) }
                            fn helper(a: u32, b: u32) -> u32 { a + b }
                        }

                        pub use self::u32::sum as sum_u32;
                        pub fn sum_f32(a: f32, b: f32) -> f32 { a + b }
                    </code></pre>
                    <pre style="width: initial">bin.rs:<code class="rust" data-line-numbers data-trim style="max-height: 550px;">
                        mod math;

                        fn main() {
                            assert!(math::sum_u32(15, 5) == 20);
                            assert!(math::sum_f32(1.5, 20.5) == 22.0);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * `mod` without body loads from external file
                        * `bin.rs` is crate entry point for binaries, `lib.rs` for libraries
                    </aside>
                </section>
                <section>
                    <h2>Multi-file crate</h2>
                    <pre style="width: initial">math/u32.rs:<code class="rust" data-line-numbers data-trim style="max-height: 550px;">
                        pub fn sum(a: u32, b: u32) -> u32 { helper(a, b) }
                        fn helper(a: u32, b: u32) -> u32 { a + b }
                    </code></pre>
                    <pre style="width: initial">math.rs:<code class="rust" data-line-numbers data-trim style="max-height: 550px;">
                        mod u32;

                        pub use self::u32::sum as sum_u32;
                        pub fn sum_f32(a: f32, b: f32) -> f32 { a + b }
                    </code></pre>
                    <pre style="width: initial">bin.rs:<code class="rust" data-line-numbers data-trim style="max-height: 550px;">
                        mod math;

                        fn main() {
                            assert!(math::sum_u32(15, 5) == 20);
                            assert!(math::sum_f32(1.5, 20.5) == 22.0);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        C/C++ differences:
                        * no `-I` or include files
                        * discoverable file and item locations
                        * no duplicate definition/declaration
                    </aside>
                </section>
                <section>
                    <h2>Contents</h2>
                    <ul>
                        <li style="color: grey;">Primitive types</li>
                        <li style="color: grey;">Ownership</li>
                        <li style="color: grey;">Control flow</li>
                        <li style="color: grey;">Code organization</li>
                        <li>Custom data types</li>
                        <li>Error handling</li>
                        <li>Heap allocated data</li>
                    </ul>
                </section>
                <section>
                    <h2>Custom data types</h2>
                    <ul>
                        <li>Data type definitions: Struct and Enum</li>
                        <li>Pattern matching</li>
                        <li>Method definitions</li>
                        <li>Traits</li>
                        <li>Generics</li>
                    </ul>
                </section>
                <section>
                    <h2>Struct initialization</h2>
                    <pre><code class="rust" data-line-numbers data-trim style="max-height: 450px;">
                        struct S {
                            field1: i32,
                            field2: f32,
                        }

                        fn main() {
                            let s1 = S { field1: 42, field2: 12.0 };
                            let s2 = S { field2: 18.0, ..s1 };
                            assert!(s2.field1 == 42 && s2.field2 == 18.0);

                            let s3 = S { field1: 15 }; //< fails to compile!
                            //       ^ missing `field2`
                            let s4 = S { }; //< fails to compile!
                            //       ^ missing `field1`, `field2`
                        }
                    </code></pre>
                </section>
                <section>
                    <h2>Struct nesting</h2>
                    <pre><code class="rust" data-line-numbers data-trim style="max-height: 450px;">
                        pub struct S {
                            pub field1: i32,
                            field2: f32,
                        }

                        struct STuple {
                            s1: S,
                            s2: S,
                        }

                        fn foo(s_tup: STuple) {
                            if s_tup.s1.field1 == s_tup.s2.field1 {
                                println!("field1 matches!");
                            }
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        field visibility rules same as other data:
                        * visible for own module and sub-modules
                        * only visible higher if marked as `pub`
                    </aside>
                </section>
                <section>
                    <h2>Tuples</h2>
                    <pre><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        // Tuple Struct
                        struct Fraction(isize, isize);

                        fn main() {
                            let f = Fraction(1, 2);
                            assert!(f.0 == 1);

                            let tup = (5, true, 42.); // type: (isize, bool, f64)
                            assert!(tup.1);
                        }

                        fn div_rem(a: isize, b: isize) -> (isize, isize) {
                            (a / b, a % b)
                        }


                        fn get_quotient(f: Fraction) -> isize {
                            let Fraction(a, b) = f;
                            let (quot, _) = div_rem(a, b);
                            quot
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Return tuple: type: `(a, b)`
                        * Note: pattern matching in `get_quotient`
                        * Note: `.` access in `main`
                    </aside>
                </section>
                <section>
                    <h2>New Type</h2>
                    <pre><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        // Single element tuple structs (new types)
                        struct Time(f32); // in seconds
                        struct Distance(f32); // in meters
                        struct Speed(f32); // in km/h

                        fn avg_speed(d: Distance, t: Time) -> Speed {
                            Speed(d.0 / t.0 * 3.6)
                        }

                        fn main() {
                            let d = Distance(402.3);
                            let t = Time(11.8);
                            assert!(avg_speed(d, t).0 > 122.5);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Encode quantity in types.
                    </aside>
                </section>
                <section>
                    <h2>Enums</h2>
                    <pre><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        enum Color {
                            Red,
                            Blue,
                            White,
                            Black,
                        }

                        fn rgb(c: Color) -> u32 {
                            match c {
                                Color::Red => 0xFF0000,
                                Color::Blue => 0x0000FF,
                                Color::White => 0xFFFFFF,
                                Color::Black => 0x000000,
                            }
                        }

                        fn main() {
                            assert!(rgb(Color::Red) == 0xFF0000);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * `match` is not yet discussed
                        * `match` is complete, cannot add more clauses
                    </aside>
                </section>
                <section>
                    <h2>Enums with data</h2>
                    <pre><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        enum Color {
                            Black,
                            White,
                            Other(u32),
                        }

                        fn rgb(c: Color) -> u32 {
                            use Color::*;
                            match c {
                                White => 0xFFFFFF,
                                Black => 0x000000,
                                Other(other_col) => other_col,
                            }
                        }

                        fn main() {
                            assert!(rgb(Color::Black) == 0x000000);
                            assert!(rgb(Color::Other(0x123456)) == 0x123456);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * use `use` to bring enum names in name space
                        * pattern matching in `match`
                    </aside>
                </section>
                <section>
                    <h2>Pattern matching</h2>
                    <pre><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        enum Color { Black, White, Other(Rgba) }
                        struct Rgba { rgb: u32, a: u8 }

                        use Color::*;
                        fn opaque(c: Color) -> bool {
                            match c {
                                White | Black
                                  | Other(Rgba { a: 0xFF, .. }) => true,
                                _ => false,
                            }
                        }

                        fn main() {
                            assert!(opaque(Black) == true);
                            assert!( opaque(Other(Rgba{a:0xFF, rgb:0})) );
                            assert!( !opaque(Other(Rgba{a:0x42, rgb:0})) );
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Rgba *after* Color
                        * No space for `r`,`g`,`b`
                        * `|` in pattern matching
                        * Pattern matching in struct
                        * Catch all: `_`
                    </aside>
                </section>
                <section>
                    <h2>Methods</h2>
                    <aside class="notes" data-markdown>
                        * Discussed all data types (except fn-pointers)
                        * Method: tying functions to data types
                    </aside>
                </section>
                <section>
                    <h2>Methods: Constructor</h2>
                    <pre><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        struct Color {r: u8, g: u8, b: u8}

                        impl Color {
                            fn new(r: u8, g: u8, b: u8) -> Color {
                                Color { r, g, b }
                            }

                            fn black() -> Self { // Self == Color
                                Color { r: 0, g: 0, b: 0 }
                            }
                        }

                        fn main() {
                            assert!(Color::new(0x00, 0x42, 0x00).g == 0x42);
                            assert!(Color::black().r == 0);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * No `self` argument => associated (static) methods
                        * Both constructors
                        * Self == own struct
                        * No function/method overloading!
                        * No need to use `Self`!
                    </aside>
                </section>
                <section>
                    <h2>Methods</h2>
                    <pre><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        struct Color {r: u8, g: u8, b: u8}

                        impl Color {
                            // ... definitions of `new` and `black` ...
                            fn intensity(&self) -> u8 {
                                let r = self.r as u16;
                                let g = self.g as u16;
                                let b = self.b as u16;
                                ((r + g + b) / 3) as u8
                            }
                        }

                        fn main() {
                            let navy_blue = Color::new(0, 0, 128);
                            assert!(navy_blue.intensity() == 42);
                            assert!(Color::black().intensity() == 0);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Note &amp; in `&amp;self`. Will come back to it later.
                    </aside>
                </section>
                <section>
                    <h2>Methods: mutability</h2>
                    <div class="fragment fade-out" data-fragment-index="1"><pre style="position:absolute; width: 100%"><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        struct Color {r: u8, g: u8, b: u8}

                        impl Color {
                            // ... definitions of `new` and `white` ...
                            fn mix(&mut self, other: Color) {
                                self.r += other.r;
                                self.g += other.g;
                                self.b += other.b;
                            }
                        }

                        fn main() {
                            let mut color = Color::new(0, 0, 128);
                            color.mix(Color::white());
                            assert!(color.b == 255);
                        }
                    </code></pre></div>
                    <div class="fragment current-visible" data-fragment-index="1"><pre style="position:absolute; width: 100%"><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        struct Color {r: u8, g: u8, b: u8}

                        impl Color {
                            // ... definitions of `new` and `white` ...
                            fn mix(&mut self, other: Color) {
                                self.r = self.r.saturating_add(other.r);
                                self.g = self.g.saturating_add(other.g);
                                self.b = self.b.saturating_add(other.b);
                            }
                        }

                        fn main() {
                            let mut color = Color::new(0, 0, 128);
                            color.mix(Color::white());
                            assert!(color.b == 255);
                        }
                    </code></pre></div>
                    <div class="fragment fade-in" data-fragment-index="2"><pre style="position:absolute; width: 100%"><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        struct Color {r: u8, g: u8, b: u8}

                        impl Color {
                            // ... definitions of `new` and `white` ...
                            fn mix(&mut self, other: Color) {
                                *self = Color {
                                    r: self.r.saturating_add(other.r),
                                    g: self.g.saturating_add(other.g),
                                    b: self.b.saturating_add(other.b),
                                };
                            }
                        }

                        fn main() {
                            let mut color = Color::new(0, 0, 128);
                            color.mix(Color::white());
                            assert!(color.b == 255);
                        }
                    </code></pre></div>
                    <aside class="notes" data-markdown>
                        * Panics in debug builds!
                        * `&amp;mut self` as `self` is allowed to change
                        * Last slide: ensure error when adding new entry to enum
                        * `*` operator: dereferencing. Often inferred.
                    </aside>
                </section>
                <section>
                    <h2>Traits and Generics</h2>
                    <ul>
                        <li>Traits: defining similar behaviors</li>
                        <li>Generics: abstracting implementations</li>
                    </ul>
                    <aside class="notes" data-markdown>
                        In C++/Java:
                        * Traits -> Interfaces
                        * Generics -> Templates
                    </aside>
                </section>
                <section>
                    <h2>Traits</h2>
                    <pre style="width:105%"><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        trait Reacts {
                            fn react(&self) -> String;
                        }

                        struct Cat {}
                        impl Reacts for Cat {
                            fn react(&self) -> String {
                                String::from("meow")
                            }
                        }

                        struct Parrot { learnt_sentence: String }
                        impl Reacts for Parrot {
                            fn react(&self) -> String { self.learnt_sentence.clone() }
                        }

                        fn main() {
                            assert_eq!(Cat {}.react(), "meow");
                            let parrot = Parrot { learnt_sentence: String::from("woof") };
                            assert_eq!(parrot.react(), "woof");
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * `String` is a heap alocated `str`, more later
                        * `String::clone` is a Trait implemenation, let's look closer
                    </aside>
                </section>
                <section>
                    <h2>Deriving Traits</h2>
                    <div class="fragment fade-out" data-fragment-index="4"><pre style="position:absolute;width:111%"><code class="rust" data-line-numbers data-noescape data-trim style="max-height: 600px;">
                        // in std: `std::clone::Clone`
                        trait Clone {
                            fn clone(&self) -> Self;
                        }

                        struct Parrot { learnt_sentence: String }
                        impl Clone for Parrot {
                            fn clone(&self) -> Parrot {
                                Parrot { learnt_sentence: self.learnt_sentence.clone() }
                            }
                        }

                        fn main() {
                            let parrot = Parrot { learnt_sentence: String::from("woof") };
                            assert!(parrot == parrot.clone());
                            <span class="fragment" data-fragment-index="2">// ^^ ERROR: binary operation `==` cannot be applied to type `Parrot`</span>
                            <span class="fragment" data-fragment-index="3">// ^^ note: an implementation of `std::cmp::PartialEq`</span>
                            <span class="fragment" data-fragment-index="3">//          might be missing for `Parrot`</span>
                        }
                    </code></pre></div>
                    <div class="fragment current-visible" data-fragment-index="4"><pre style="position:absolute;width:110%"><code class="rust" data-line-numbers data-noescape data-trim style="max-height: 600px;">
                        // in std: `std::clone::Clone`
                        trait Clone {
                            fn clone(&self) -> Self;
                        }

                        <mark>#[derive(PartialEq)]</mark>
                        struct Parrot { learnt_sentence: String }
                        impl Clone for Parrot {
                            fn clone(&self) -> Parrot {
                                Parrot { learnt_sentence: self.learnt_sentence.clone() }
                            }
                        }

                        fn main() {
                            let parrot = Parrot { learnt_sentence: String::from("woof") };
                            assert!(parrot == parrot.clone());
                        }
                    </code></pre></div>
                    <div class="fragment fade-in" data-fragment-index="5"><pre style="position:absolute;width:110%"><code class="rust" data-line-numbers data-noescape data-trim style="max-height: 600px;">
                        // in std: `std::clone::Clone`
                        trait Clone {
                            fn clone(&self) -> Self;
                        }

                        #[derive(PartialEq, <mark>Clone</mark>)]
                        struct Parrot { learnt_sentence: String }

                        fn main() {
                            let parrot = Parrot { learnt_sentence: String::from("woof") };
                            assert!(parrot == parrot.clone());
                        }
                    </code></pre></div>
                    <aside class="notes" data-markdown>
                        * Provide our own clone implementation
                        * Fails: no `==` for `Parrot`

                        * Deriving `PartialEq`: let the compiler generate the code
                        * For `PartialEq`, equal if *all* fields are equal
                        * Difference `PartialEq` and `Eq`? f64
                    </aside>
                </section>
                <section>
                    <h2>Using Traits</h2>
                    <pre style="width: 100%"><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        trait Reacts {
                            fn react(&self) -> String;
                        }
                        // Definition of `Cat`

                        fn loud_reaction_dynamic(reactor: &dyn Reacts) -> String {
                            format!("{}!", reactor.react().to_uppercase())
                        }
                        fn loud_reaction_generic&lt;R: Reacts&gt;(reactor: &R) -> String {
                            format!("{}!", reactor.react().to_uppercase())
                        }

                        fn main() {
                            let reactor: &dyn Reacts = &Cat {};
                            assert_eq!(loud_reaction_dynamic(reactor), "MEOW!");

                            assert_eq!(loud_reaction_generic(&Cat {}), "MEOW!");
                            // vvv   Fails compilation!   vvv
                            assert_eq!(loud_reaction_generic(reactor), "MEOW!");
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * `format!` macro to do string formatting
                        * `_dynamic`'s `reactor` will have v-table, only one piece of code
                        * `_generic` needs to know type of `R` beforehand
                        * `_generic` will be monomorphised for each type of `R`
                        * `&Cat {}` allocates a `Cat` instance on the stack and returns reference to it
                    </aside>
                </section>
                <section>
                    <h2>Generic Data Types</h2>
                    <pre><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        trait Reacts {
                            fn react(&self) -> String;
                        }

                        struct LoudReactor&lt;R: Reacts&gt;(R);
                        impl&lt;R: Reacts&gt; Reacts for LoudReactor&lt;R&gt; {
                            fn react(&self) -> String {
                                format!("{}!", self.0.react().to_uppercase())
                            }
                        }

                        // Definition of `Cat`

                        fn main() {
                            let cat = Cat {};
                            assert_eq!(cat.react(), "meow");

                            let loud_cat = LoudReactor(cat); // : LoudReactor&lt;Cat&gt;
                            assert_eq!(loud_cat.react(), "MEOW!");
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * `R: Reacts` puts a bound on `R`, `R` has to implement `Reacts`
                        * `LoudReactor&lt;A&gt;` is a different type then `LoudReactor&lt;B&gt;`
                        * Cannot instantiate a `LoudReactor` without type parameter
                    </aside>
                </section>
                <section>
                    <h2>Contents</h2>
                    <ul>
                        <li style="color: grey;">Primitive types</li>
                        <li style="color: grey;">Ownership</li>
                        <li style="color: grey;">Control flow</li>
                        <li style="color: grey;">Code organization</li>
                        <li style="color: grey;">Custom data types</li>
                        <li>Error handling</li>
                        <li>Heap allocated data</li>
                    </ul>
                </section>
                <section>
                    <h2>Error Handling</h2>
                    <ul>
                        <li>Option</li>
                        <li>Result</li>
                        <li><span><code style="font-size: 1em">?</code></span> Operator</li>
                    </ul>
                </section>
                <section>
                    <h2>Option</h2>
                    <pre><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        /// Option in core language
                        enum Option&lt;T> {
                            Some(T),
                            None,
                        }

                        // In the core language as: `a.checked_div(b)`.
                        fn safe_div(a: usize, b: usize) -> Option&lt;usize> {
                            if b != 0 {
                                Some(a / b)
                            } else {
                                None
                            }
                        }

                        fn main() {
                            assert!(safe_div(1, 0) == None);
                            assert!(safe_div(1, 2) == Some(0));
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * in C: like returning `NULL`
                        * have to check for `Some`
                    </aside>
                </section>
                <section>
                    <h2>Result</h2>
                    <pre style="width: 100%"><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        /// Result&lt;T, E> in core language
                        enum Result&lt;T, E> {
                            Ok(T),
                            Err(E),
                        }
                        #[derive(PartialEq)]
                        enum Error { DivByZero, HasRemainder(f32) }
                        fn non_rem_div(a: usize, b: usize) -> Result&lt;usize, Error> {
                            if b == 0 {
                                Err(Error::DivByZero)
                            } else if a % b == 0 {
                                Ok(a / b)
                            } else {
                                Err(Error::HasRemainder(a as f32 / b as f32))
                            }
                        }
                        fn main() {
                            assert!(non_rem_div(4, 2) == Ok(2));
                            assert!(non_rem_div(5, 0) == Err(Error::DivByZero));
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Contrived example.
                        * Create special error types to indicate what went wrong.
                        * Deriving `PartialEq`!
                    </aside>
                </section>
                <section>
                    <h2><span><code style="font-size: 1em">?</code> Operator</span></h2>
                    <div class="fragment fade-out" data-fragment-index="1"><pre style="position:absolute;"><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        fn solve(problem: Option&lt;u32>) -> Option&lt;u32> {
                            let p = match problem {
                                Some(p) => p,
                                None => return None,
                            };

                            Some(p * 42)
                        }

                        fn main() {
                            assert_eq!(solve(Some(2)), Some(84));
                            assert_eq!(solve(None), None);
                        }
                    </code></pre></div>
                    <div class="fragment current-visible" data-fragment-index="1"><pre style="position:absolute;"><code class="rust" data-line-numbers data-trim data-noescape style="max-height: 600px;">
                        fn solve(problem: Option&lt;u32>) -> Option&lt;u32> {
                            let p = problem<mark>?</mark>;

                            Some(p * 42)
                        }

                        fn main() {
                            assert_eq!(solve(Some(2)), Some(84));
                            assert_eq!(solve(None), None);
                        }
                    </code></pre></div>
                    <div class="fragment fade-in" data-fragment-index="2"><pre style="position:absolute;"><code class="rust" data-line-numbers data-trim data-noescape style="max-height: 600px;">
                        fn solve(problem: Option&lt;u32>) -> Option&lt;u32> {
                            Some(problem? * 42)
                        }

                        fn main() {
                            assert_eq!(solve(Some(2)), Some(84));
                            assert_eq!(solve(None), None);
                        }
                    </code></pre></div>
                    <aside class="notes" data-markdown>
                    </aside>
                </section>
                <section>
                    <h2>Contents</h2>
                    <ul>
                        <li style="color: grey;">Primitive types</li>
                        <li style="color: grey;">Ownership</li>
                        <li style="color: grey;">Control flow</li>
                        <li style="color: grey;">Code organization</li>
                        <li style="color: grey;">Custom data types</li>
                        <li style="color: grey;">Error handling</li>
                        <li>Heap allocated data</li>
                    </ul>
                </section>
                <section>
                    <h2>Heap allocated data</h2>
                    <ul>
                        <li>Smart Pointers: Box, Rc, Vec, String</li>
                        <li>Copying &amp; Moving</li>
                    </ul>
                </section>
                <section>
                    <h2>Box</h2>
                    <pre style="width:100%"><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        // in std library
                        struct Box&lt;T&gt;(_, _);

                        fn first_32_numbers() -> Box<[u32; 32]> {
                            let mut ints = Box::new([0; 32]);
                            for i in 0..32 {
                                ints[i as usize] = i;
                            }
                            ints
                        }

                        fn main() {
                            let many_nums = first_32_numbers();
                            assert!(many_nums[5] == 5);
                            let more_nums = first_32_numbers();
                            assert!(many_nums == more_nums);

                            use std::mem::{size_of, size_of_val};
                            assert!(size_of_val(&more_nums) == size_of::&lt;usize>());
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * 32 heap-allocated `u32`s
                        * Deallocated when falling out of scope
                        * Size on stack of `Box` is equal to size of a pointer
                    </aside>
                </section>
                <section>
                    <h2>Vec</h2>
                    <pre style="width: initial;"><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        fn first_n_ints(n: u32) -> Vec&lt;u32> {
                            let mut ints = Vec::new();
                            for i in 0..n {
                                ints.push(i);
                            }
                            ints
                        }

                        fn main() {
                            let mut five_ints = first_n_ints(5);
                            assert!(five_ints.len() == 5);
                            assert!(five_ints[4] == 4); //< Panics when out of bounds!
                            assert!(five_ints.get(5) == None);

                            five_ints.push(42);
                            assert!(five_ints.len() == 6);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * `Vec`: a contiguous growable array type
                        * Deallocated when falling out of scope
                        * Prefer using `Vec::get` to handle out of bounds
                        * How many length checks in release code? 1!
                    </aside>
                </section>
                <section style="width: 115%; left: -7.5%;">
                    <h2>Moving vs Copying</h2>
                    <div class="fragment fade-out" data-fragment-index="1"><pre style="position:absolute; width: 102%;"><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        fn sum(ns: Box&lt;[u32]>) -> u32 {
                            let mut sum = 0;
                            for n in ns.iter() {
                                sum += n;
                            }
                            sum
                        }

                        fn main() {
                            let nums = Box::new([1, 2, 5, 8, 10]);
                            let s = sum(nums);
                            assert!(s == 26);
                        }
                    </code></pre></div>
                    <div class="fragment current-visible" data-fragment-index="1"><pre style="position:absolute; width: 102%;"><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        fn sum(ns: Box&lt;[u32]>) -> u32 {
                            let mut sum = 0;
                            for n in ns.iter() {
                                sum += n;
                            }
                            sum
                        }

                        fn main() {
                            let nums = Box::new([1, 2, 5, 8, 10]);
                            let s = sum(nums);
                            assert!(s == 26);

                            let nums2 = nums; //?
                        }
                    </code></pre></div>
                    <div class="fragment current-visible" data-fragment-index="2"><pre style="position:absolute; width: 102%;"><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        fn sum(ns: Box&lt;[u32]>) -> u32 {
                            let mut sum = 0;
                            for n in ns.iter() {
                                sum += n;
                            }
                            sum
                        }

                        fn main() {
                            let nums = Box::new([1, 2, 5, 8, 10]);
                            //  ---- move occurs because `nums` has type `std::boxed::Box<[u32; 5]>`,
                            //  which does not implement the `Copy` trait
                            let s = sum(nums);
                            //          ---- value moved here
                            assert!(s == 26);
                            let nums2 = nums;
                            //          ^^^^ value used here after move
                        }
                        // error[E0382]: use of moved value: `nums`
                    </code></pre></div>
                    <div class="fragment current-visible" data-fragment-index="3"><pre style="position:absolute; width: 102%;"><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        fn add_2(n: u32) -> u32 {
                            n + 2
                        }

                        fn main() {
                            let n = 3;
                            assert!(add_2(n));

                            // Allowed because `u32` implements `Copy`
                            let n2 = n;
                        }
                    </code></pre></div>
                    <div class="fragment current-visible" data-fragment-index="4"><pre style="position:absolute; width: 102%;"><code class="rust" data-line-numbers data-trim style="max-height: 600px;">
                        fn sum(ns: Box&lt;[u32]>) -> u32 {
                            let mut sum = 0;
                            for n in ns.iter() {
                                sum += n;
                            }
                            sum
                        }

                        fn main() {
                            let nums = Box::new([1, 2, 5, 8, 10]);
                            let s = sum(nums.clone());
                            assert!(s == 26);

                            let nums2 = nums;
                            // let s = sum(nums); //< Illegal!
                            assert!(sum(nums2) == 26);
                        }
                    </code></pre></div>
                    <div class="fragment fade-in" data-fragment-index="5"><pre style="position:absolute; width: 102%;"><code class="rust" data-line-numbers
                     data-trim style="max-height: 600px;">
                        fn sum(ns: &[u32]) -> u32 {
                            let mut sum = 0;
                            for n in ns.iter() {
                                sum += n;
                            }
                            sum
                        }

                        fn main() {
                            let nums = Box::new([1, 2, 5, 8, 10]);
                            let s = sum(nums.as_ref());
                            assert!(s == 26);

                            let nums2 = nums;
                            // let s = sum(nums.as_ref()); //< Illegal!
                            assert!(sum(nums2.as_ref()) == 26);
                        }
                    </code></pre></div>
                    <aside class="notes" data-markdown>
                        * Boxed array (fixed-size) to Boxed slice
                        * Box deallocated in sum!
                        * Using `nums` after `sum` call?
                    </aside>
                </section>
                <section>
                    <h2>Where go from here?</h2>
                    <p>
                        <ul>
                            <li>Installing: <a href="https://www.rust-lang.org/tools/install">rust-lang.org/tools/install</a></li>
                            <li>Learn: <a href="https://www.rust-lang.org/learn">rust-lang.org/learn</a>
                                <ul>
                                    <li>Rust book: <a href="https://doc.rust-lang.org/book/">doc.rust-lang.org/book</a></li>
                                    <li>Standard library: <a href="https://doc.rust-lang.org/std"/>doc.rust-lang.org/std</a></li>
                                </ul>
                            </li>
                            <li>Playground: <a href="https://play.rust-lang.org/">play.rust-lang.org</a></li>
                            <li>These slides: <a href="https://hugwijst.github.io/rust-primer/">hugwijst.github.io/rust-primer</a></li>
                        </ul>
                    </p>
                    <aside class="notes" data-markdown>
                        * No dynamic memory management, run-time
                        * Namespacing, file inclusion, lambdas
                        * Package manager
                    </aside>
                </section>
                <section>
                    <pre style="width:50%"><code class="rust" data-line-numbers="2" data-trim>
                        fn main() {
                            println!("Questions?");
                        }
                    </code></pre>
                </section>
            </div>
        </div>

        <script src="reveal.js-4.1.2/dist/reveal.js"></script>

        <script src="reveal.js-4.1.2/plugin/notes/notes.js"></script>
        <script src="reveal.js-4.1.2/plugin/markdown/markdown.js"></script>
        <script src="reveal.js-4.1.2/plugin/highlight/highlight.js"></script>

        <script>
            Reveal.initialize({
                slideNumber: true,
                plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ],
            }).then( () => {
                var hljs = Reveal.getPlugin('highlight');
                document.querySelectorAll('span>code').forEach((block) => {
                    hljs.highlightBlock(block);
                });
                document.querySelectorAll('.inline-code code').forEach((block) => {
                    hljs.highlightBlock(block);
                });
           });
        </script>
    </body>
</html>

<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>Rust + TFD</title>

        <link rel="stylesheet" href="reveal.js-3.6.0/css/reveal.css">
        <link rel="stylesheet" href="reveal.js-3.6.0/css/theme/black.css">

        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="reveal.js-3.6.0/lib/css/zenburn.css">

        <style type="text/css">
            .reveal span>code, .inline-code code {
                line-height: 1.2em;
                font-size: 0.55em;
                padding: 5px;
                width: 100%;
                display: inline;
            }
        </style>

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js-3.6.0/css/print/pdf.css' : 'reveal.js-3.6.0/css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h2>Rust Primer</h2>
                    <h3></h3>
                </section>
                <section>
                    <h2>What is Rust?</h2>
                    <p>
                        <ul>
                            <li>Systems programming language</li>
                            <li>Strong static typing</li>
                            <li>Guarenteed memory safety<span style="color: red;">*</span></li>
                            <li>No undefined behavior<span style="color: red;">*</span></li>
                        </ul>
                    </p>
                    <p style="text-align: right;" class="fragment">
                        <span style="color: red;">*</span>except when using ðŸ‘»unsafeðŸ‘»
                    </p>
                    <img src="rust-logo-white.svg" style="border: 0; background: 0; box-shadow: unset; margin: auto 0;">
                    <aside class="notes" data-markdown>
                        * No dynamic memory management, run-time
                        * Namespacing, file inclusion, lambdas
                        * Package manager
                    </aside>
                </section>
                <section>
                    <h2>Contents</h2>
                    <ul>
                        <li>Primitive types</li>
                        <li>Ownership</li>
                        <li>Control flow</li>
                        <li>Custom data types</li>
                        <li>Error handling</li>
                    </ul>
                </section>
                <section>
                    <h2>Primitive types</h2>
                    <ul class="rust">
                        <li><span class="rust"><code>bool</code> (<code>true</code>, <code>false</code>)</span></li>
                        <li><span class="rust">
                            <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>
                            (<code>12u8</code>, <code>b'a'</code>, <code>65_536u32</code>)
                        </span></li>
                        <li><span class="rust">
                            <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>
                            (<code>0x1EEFi16</code>, <code>-3_000_000_000i64</code>)
                        </span></li>
                        <li><span class="rust">
                            <code>usize</code>, <code>isize</code> (<code>15usize</code>, <code>-12isize</code>)
                        </span></li>
                        <li><span class="rust">
                            <code>f32</code>, <code>f64</code> (<code>1e24f32</code>, <code>0.24f64</code>)
                        </span></li>
                        <li><span class="rust">
                            <code>char</code> (<code>'a'</code>, <code>'ðŸ’¡'</code>)
                        </span></li>
                    </ul>
                    <aside class="notes" data-markdown>
                        * note suffix
                        * `b'a'` is an unsigned byte
                        * `usize`, `isize`: size of a native word on the architecture
                        * `_` to help readability of numbers
                        * `char` is a **UTF-8** character, size: 4 bytes!
                    </aside>
                </section>
                <section>
                    <h2>Assignment</h2>
                    <pre><code class="rust" data-trim>
                        fn main() {
                            let x: u32 = 24u32; // fully explicit
                            let x = 16u8;       // infered type of `x`
                            let x: f32 = 12.;   // infered type of `12.`
                            let x = 42;         // defaults to isize
                            let x = 42u;        // or usize when unsigned
                            let x = 42.;        // or f64 when float
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Note: shadowing of local variables
                    </aside>
                </section>
                <section>
                    <h2>Casting</h2>
                    <pre><code class="rust" data-trim>
                        fn main() {
                            let x: u32 = 12u8;          //< fails to compile!
                            //           ^^^^ expected u32, found u8
                            let x: u32 = 12u64;         //< fails to compile!
                            //           ^^^^^ expected u32, found u64
                            let x: u32 = 12u64 as u32;  // x == 12

                            let x = 400u16 as u8;       // x == 144
                            let x = -3i8 as u8;         // x == 253
                        }
                    </code></pre>
                </section>
                <section>
                    <h2>Mutability</h2>
                    <pre><code class="rust" data-trim>
                        fn main() {
                            let x = 41;
                            x = 42;         //< fails to compile!
                        //  ^^^^^^ cannot assign twice to immutable variable
                            let x = 42;

                            let mut x = 41;
                            x = 42;
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Shadowing preferred for non-mutable data
                    </aside>
                </section>
                <section>
                    <h2>References</h2>
                    <pre><code class="rust" data-trim>
                        fn main() {
                            let x = 41u32;
                            let y = 42;
                            let r: &amp;u32 = &amp;x;  assert!(*r == 41);
                            r = &amp;y;  //< fails to compile!
                        //  ^^^^^^ cannot assign twice to immutable variable

                            let mut s = &amp;y;    assert!(*r == 42);
                            s = &amp;x;            assert!(*r == 41);
                            *s = 4; //< fails to compile!
                        //  ^^^^^^ `s` is a `&` reference, so the data it refers to
                        //         cannot be written
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                    </aside>
                </section>
                <section>
                    <h2>Mutable References</h2>
                    <pre><code class="rust" data-trim>
                        fn main() {
                            let x = 41u32;
                            let r: &amp;mut u32 = &amp;mut x; //< fails to compile!
                            //                ^^^^^^ cannot borrow as mutable

                            let mut x = 41;
                            let r: &amp;mut u32 = &amp;mut x;  assert!(*r == 41);
                            *r = 42;  assert!(*r == 42);
                            assert!(x == 42);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                    </aside>
                </section>
                <section>
                    <h2>Ownership 1</h2>
                    <pre><code class="rust" data-noescape data-trim>
                        fn main() {
                            let mut x = 41;

                            let r = &amp;x;
                            <span class="fragment" data-fragment-index="2">//      -- immutable borrow occurs here</span>
                            let r_mut = &amp;mut x;
                            <span class="fragment" data-fragment-index="2">//          ^^^^^^ mutable borrow occurs here</span>
                            assert!(*r == *r_mut); //< fails to compile!
                            <span class="fragment" data-fragment-index="2">//      -- immutable borrow later used here</span>
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        Either many immutable borrows *OR* one mutable borrow.
                    </aside>
                </section>
                <section>
                    <h2>Ownership 2</h2>
                    <pre><code class="rust" data-noescape data-trim>
                        fn main() {
                            let mut x = 41;

                            let r_mut = &amp;mut x;
                            <span class="fragment" data-fragment-index="2">//          ------ borrow of `x` occurs here</span>
                            assert!(x == *r_mut); //< fails to compile!
                            <span class="fragment" data-fragment-index="2">//      ^    ------ borrow later used here
                            //      |
                            //      use of borrowed `x`</span>
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        No access to borrowed variables.
                    </aside>
                </section>
                <section>
                    <h2>Ownership 3</h2>
                    <pre><code class="rust" data-noescape data-trim>
                        fn main() {
                            let mut x = 41;

                            let r = &amp;x;
                        <span class="fragment" data-fragment-index="2">//          -- borrow of `x` occurs here</span>
                            assert!(x == *r);

                            x = 42;
                        <span class="fragment" data-fragment-index="2">//  ^^^^^^ assignment to borrowed `x` occurs here</span>
                            assert!(x == *r); //< fails to compile!
                        <span class="fragment" data-fragment-index="2">//               -- borrow later used here</span>
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        No access to borrowed variables.
                    </aside>
                </section>
                <section>
                    <h2>Uninitialized References</h2>
                    <pre><code class="rust" data-trim>
                        fn main() {
                            let r: &amp;u32;
                            assert!(*r == 4); //< fails to compile!
                            //      ^^ use of possibly uninitialized `*r`
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Note: shadowing of local variables
                    </aside>
                </section>
                <section>
                    <h2>Arrays</h2>
                    <pre><code class="rust" data-trim>
                        fn main() {
                            let array: [i32; 3] = [1, 4, -3];

                            assert!(array[0] == 1);
                            assert!(array[3] == 4); //< Fails to compile!

                            let n = 3;
                            assert!(array[n] == 4); //< Panics!

                            let all_5s = [5u8; 5];
                            assert!(all_5s == [5, 5, 5, 5, 5]);
                            assert!(all_5s.len() == 5);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Array is fixed size.
                        * In example array stored on stack.
                        * Needs to be fully initialized!
                        * Panics on out-of-bounds index access.
                    </aside>
                </section>
                <section>
                    <h2>Slices</h2>
                    <pre><code class="rust" data-trim style="max-height: 100%">
                        fn main() {
                            let arr1: [i32; 3] = [1, 4, -3];

                            let mut arr_ref: &amp;[i32] = &amp;arr1;
                            assert!(arr_ref[0] == 1);
                            assert!(arr_ref[3] == 4); //< Panics!

                            let arr2 = [1, 2, 3, 4, 5];
                            arr_ref = &amp;arr2;
                            assert!(*arr_ref == [1, 2, 3, 4, 5]);

                            arr_ref = &amp;arr_ref[2..];
                            assert!(arr_ref == [3, 4, 5]);
                            assert!(arr_ref.len() == 3);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Slice: reference to contiguous data **and** length
                        * Panics on out-of-bounds index access.
                        * Can create and store subslice with range.
                        * `*` can often be elided.
                    </aside>
                </section>
                <section>
                    <h2>String slices</h2>
                    <pre style="width: initial;"><code class="rust" data-trim>
                        fn main() {
                            let hello_world: &str = "Hello World ðŸ‘‹!";

                            assert!(hello_world.len() == 17); // in bytes!
                            assert!(hello_world.chars().len() == 14);

                            assert!(&hello_world[..5] == "Hello");
                            assert!(&hello_world[..12] == "Hello World ");
                            assert!(&hello_world[..13] == "Hello World "); //< Panics!

                            assert!("".len() == 0);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Slice: reference to contiguous data **and** length
                        * Panics on out-of-bounds index access.
                        * Can create and store subslice with range.
                        * `*` can often be elided.
                    </aside>
                </section>
                <section data-markdown class="inline-code">
                    <textarea data-template>
                        ## Operators

                        * numeric (`+`, `-`, `*`, `/`, `%`)
                        * bitwise (`|`, `&`, `^`, `<<`, `>>`)
                        * comparison (`==`, `!=`, `>`, `<`, `>=`, `<=`)
                        * logical (`||`, `&&`)
                        * number negation (`-`)
                        * boolean negation (`!`)
                        * number bitwise negation (`!`) <span class="fragment" data-fragment-index="1">ðŸš¨</span>
                        * compound assignment (`+=`, `|=`, etc.)
                        * **NO**: increment/decrement (`++`, `--`)
                    </textarea>
                    <aside class="notes" data-markdown>
                        * logical operations only on `bool`
                        * bitwise negation is non-C
                    </aside>
                </section>
                <section>
                    <h2>Control flow: if</h2>
                    <pre class="fragment fade-out" data-fragment-index="1" style="position:absolute;width:100%"><code class="rust" data-trim>
                        fn min(a: usize, b: usize) -> usize {
                            let ret;
                            if a < b {
                                ret = a;
                            } else {
                                ret = b;
                            }
                            return ret;
                        }

                        fn main() {
                            assert!(min(5,8) == 5);
                        }
                    </code></pre>
                    <pre class="fragment current-visible" data-fragment-index="1" style="position:absolute;width:100%"><code class="rust" data-trim>
                        fn min(a: usize, b: usize) -> usize {
                            let ret;
                            if a < b {
                                ret = a;
                            } else {
                                ret = b;
                            }
                            ret
                        }

                        fn main() {
                            assert!(min(5,8) == 5);
                        }
                    </code></pre>
                    <pre class="fragment current-visible" data-fragment-index="2" style="position:absolute;width:100%"><code class="rust" data-trim data-noescape>
                        fn min(a: usize, b: usize) -> usize {
                            let ret <mark>=</mark> if a < b { a } else { b }<mark>;</mark>
                            ret
                        }

                        fn main() {
                            assert!(min(5,8) == 5);
                        }
                    </code></pre>
                    <pre class="fragment fade-in" data-fragment-index="3" style="position:absolute;width:100%"><code class="rust" data-trim data-noescape>
                        fn min(a: usize, b: usize) -> usize {
                            if a < b { a } else { b }
                        }

                        fn main() {
                            assert!(min(5,8) == 5);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Note: first non-`main` function!
                        * No braces around condition expression
                        * `if` is and expression, not a statement
                    </aside>
                </section>
                <section>
                    <h2>Closures</h2>
                    <pre style="width: initial;"><code class="rust" data-trim style="max-height: 500px;">
                        fn min(a: usize, b: usize) -> usize {
                            if a < b { a } else { b }
                        }

                        fn main() {
                            fn local_min(a: usize, b: usize) -> usize {
                                if a < b { a } else { b }
                            }
                            assert!(min(1, 2) == 1);
                            assert!(local_min(1, 2) == 1);

                            let closure_min = |a, b| if a < b { a } else { b };
                            assert!(closure_min(5, 8) == 5);

                            let a = 4;
                            let min_of_a_and = |b| if a < b { a } else { b };
                            assert!(min_of_a_and(8) == 4);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Contrived :)
                        * Local functions
                        * Closure captures environment
                        * Closure useful when passed to function, see later
                    </aside>
                </section>
                <section>
                    <h2>Control flow: loop</h2>
                    <pre><code class="rust" data-trim style="max-height: 450px;">
                        fn main() {
                            let start = 3;
                            let mut x = start;

                            while x > 0 {
                                println!("down = {}", x);
                                x -= 1;
                            }

                            loop {
                                println!("up = {}", x);
                                x += 1;

                                if x >= start { break }
                            }
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * No do-while!
                    </aside>
                </section>
                <section>
                    <h2>Control flow: for-loop</h2>
                    <pre><code class="rust" data-trim style="max-height: 450px;">
                        fn main() {
                            let mut x = 0;

                            for i in 1..5 {
                                x += i;
                            }

                            assert!(x == 10);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * `1..5` is a range, 1-inclusive and 5-exclusive
                        * `for` iterates over een iterator, a range is an iterator
                    </aside>
                </section>
                <section>
                    <h2>Iterator: filter + map</h2>
                    <pre><code class="rust" data-trim style="max-height: 450px;">
                        fn main() {
                            let mut x = 0;
                            for i in (1..10).filter(|x| x % 2 == 0) {
                                x += i; // i <- [2, 4, 6, 8]
                            }
                            assert!(x == 20);

                            x = 0;
                            for i in (1..5).map(|x| x * 3 + 1)  {
                                x += i; // i <- [4, 7, 10, 13]
                            }
                            assert!(x == 34);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * explain `filter` and `map` methods
                    </aside>
                </section>
                <section>
                    <h2>Code organization</h2>
                    <ul>
                        <li>Modules</li>
                        <li>Visibility</li>
                        <li>Files</li>
                        <li>Crates</li>
                    </ul>
                </section>
                <section>
                    <h2>Modules</h2>
                    <pre><code class="rust" data-trim style="max-height: 450px;">
                        mod math {
                            pub fn sum_u32(a: u32, b: u32) -> u32 {
                                a + b
                            }

                            pub fn sum_f32(a: f32, b: f32) -> f32 {
                                a + b
                            }
                        }

                        fn main() {
                            assert!(math::sum_u32(15, 5) == 20);

                            use math::sum_f32;
                            assert!(sum_f32(1.5, 20.5) == 22.0);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * `mode` use for organizing code in different name spaces
                        * import into current name space using `use`
                    </aside>
                </section>
                <section>
                    <h2>Visibility</h2>
                    <pre><code class="rust" data-trim style="max-height: 450px;">
                        mod math {
                            pub mod u32 {
                                pub fn sum_u32(a: u32, b: u32) -> u32 { helper(a, b) }
                                fn helper(a: u32, b: u32) -> u32 { a + b }
                            }

                            pub fn sum_f32(a: f32, b: f32) -> f32 { a + b }
                        }

                        fn main() {
                            assert!(math::sum_u32(15, 5) == 20);

                            use math::sum_f32;
                            assert!(sum_f32(1.5, 20.5) == 22.0);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * `mode` use for organizing code in different name spaces
                        * import into current name space using `use`
                    </aside>
                </section>
                <section>
                    <h2>Custom data types</h2>
                    <ul>
                        <li>Data type definitions: Struct and Enum</li>
                        <li>Pattern matching</li>
                        <li>Method definitions</li>
                        <li>Traits</li>
                        <li>Generics</li>
                    </ul>
                </section>
                <section>
                    <h2>Struct defintion</h2>
                    <pre><code class="rust" data-trim style="max-height: 450px;">
                        struct S {
                            field1: i32,
                            field2: f32,
                        }

                        struct AnotherStruct {
                            s1: S,
                            s2: S,
                        }

                        fn foo(another_s: AnotherStruct) {
                            if another_s.s1.field1 == another_s.s2.field1 {
                                println!("field1 matches!");
                            }
                        }
                    </code></pre>
                </section>
                <section>
                    <h2>Struct initialization</h2>
                    <pre><code class="rust" data-trim style="max-height: 450px;">
                        struct S {
                            field1: i32,
                            field2: f32,
                        }

                        fn main() {
                            let s1 = S { field1: 42, field2: 12.0 };
                            let s2 = S { field2: 18.0, ..s1 };
                            assert!(s2.field1 == 42 && s2.field2 == 18.0);

                            let s3 = S { field1: 15 }; //< fails to compile!
                            //       ^ missing `field2`
                            let s4 = S { }; //< fails to compile!
                            //       ^ missing `field1`, `field2`
                        }
                    </code></pre>
                </section>
                <section>
                    <h2>Tuples</h2>
                    <pre><code class="rust" data-trim style="max-height: 600px;">
                        fn div_rem(a: isize, b: isize) -> (isize, isize) {
                            (a / b, a % b)
                        }

                        // Tuple Struct
                        struct Fraction(isize, isize);

                        fn fraction_quotient(f: Fraction) -> isize {
                            let Fraction(a, b) = f;
                            let (quot, _) = div_rem(a, b);
                            quot
                        }

                        fn main() {
                            let f = Fraction(1, 2);
                            assert!(f.0 == 1);

                            let tup = (5, true, 42.); // type: (isize, bool, f64)
                            assert!(tup.1);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Note: pattern matching in `fraction_quotient`
                        * Note: `.` access in `main`
                    </aside>
                </section>
                <section>
                    <h2>New Type</h2>
                    <pre><code class="rust" data-trim style="max-height: 600px;">
                        // Single element tuple structs (new types)
                        struct Time(f32); // in seconds
                        struct Distance(f32); // in meters
                        struct Speed(f32); // in km/h

                        fn avg_speed(d: Distance, t: Time) -> Speed {
                            Speed(d.0 / t.0 * 3.6)
                        }

                        fn main() {
                            let d = Distance(402.3);
                            let t = Time(11.8);
                            assert!(avg_speed(d, t).0 > 122.5);
                        }
                    </code></pre>
                </section>
                <section>
                    <h2>Enums</h2>
                    <pre><code class="rust" data-trim style="max-height: 600px;">
                        enum Color {
                            Red,
                            Blue,
                            White,
                            Black,
                        }

                        fn rgb(c: Color) -> u32 {
                            match c {
                                Color::Red => 0xFF0000,
                                Color::Blue => 0x0000FF,
                                Color::White => 0xFFFFFF,
                                Color::Black => 0x000000,
                            }
                        }

                        fn main() {
                            assert!(rgb(Color::Red) == 0xFF0000);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * `match` is not yet discussed
                        * `match` is complete
                    </aside>
                </section>
                <section>
                    <h2>Enums with data</h2>
                    <pre><code class="rust" data-trim style="max-height: 600px;">
                        enum Color {
                            Black,
                            White,
                            Other(u32),
                        }

                        fn rgb(c: Color) -> u32 {
                            use Color::*;
                            match c {
                                White => 0xFFFFFF,
                                Black => 0x000000,
                                Other(other_col) => other_col,
                            }
                        }

                        fn main() {
                            assert!(rgb(Color::Black) == 0x000000);
                            assert!(rgb(Color::Other(0x123456)) == 0x123456);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * use `use` to bring enum names in name space
                        * pattern matching in `match`
                    </aside>
                </section>
                <section>
                    <h2>Pattern matching</h2>
                    <pre><code class="rust" data-trim style="max-height: 600px;">
                        enum Color { Black, White, Other(Rgba) }
                        struct Rgba { rgb: u32, a: u8 }

                        use Color::*;
                        fn opaque(c: Color) -> bool {
                            match c {
                                White | Black
                                  | Other(Rgba { a: 0xFF, .. }) => true,
                                _ => false,
                            }
                        }

                        fn main() {
                            assert!(opaque(Black) == true);
                            assert!( opaque(Other(Rgba{a:0xFF, rgb:0})) );
                            assert!( !opaque(Other(Rgba{a:0x42, rgb:0})) );
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Rgba *after* Color
                        * No space for `r`,`g`,`b`
                        * `|` in pattern matching
                        * Pattern matching in struct
                        * Catch all: `_`
                    </aside>
                </section>
                <section>
                    <h2>Methods</h2>
                    <aside class="notes" data-markdown>
                        * Discussed all data types (except fn-pointers)
                        * Method: tying functions to data types
                    </aside>
                </section>
                <section>
                    <h2>Methods: Constructor</h2>
                    <pre><code class="rust" data-trim style="max-height: 600px;">
                        struct Color {r: u8, g: u8, b: u8}

                        impl Color {
                            fn new(r: u8, g: u8, b: u8) -> Color {
                                Color { r, g, b }
                            }

                            fn black() -> Self { // Self == Color
                                Color { r: 0, g: 0, b: 0 }
                            }
                        }

                        fn main() {
                            assert!(Color::new(0x00, 0x42, 0x00).g == 0x42);
                            assert!(Color::black().r == 0);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * No `self` argument => associated (static) methods
                        * Both constructors
                        * Self == own struct
                        * No function/method overloading!
                        * No need to use `Self`!
                    </aside>
                </section>
                <section>
                    <h2>Methods</h2>
                    <pre><code class="rust" data-trim style="max-height: 600px;">
                        struct Color {r: u8, g: u8, b: u8}

                        impl Color {
                            // ... definitions of `new` and `black` ...
                            fn intensity(&self) -> u8 {
                                let r = self.r as u16;
                                let g = self.g as u16;
                                let b = self.b as u16;
                                ((r + g + b) / 3) as u8
                            }
                        }

                        fn main() {
                            let navy_blue = Color::new(0, 0, 128);
                            assert!(navy_blue.intensity() == 42);
                            assert!(Color::black().intensity() == 0);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Note &amp; in `&amp;self`. Will come back to it later.
                    </aside>
                </section>
                <section>
                    <h2>Methods: mutability</h2>
                    <pre class="fragment fade-out" data-fragment-index="1" style="position:absolute; width: 100%"><code class="rust" data-trim style="max-height: 600px;">
                        struct Color {r: u8, g: u8, b: u8}

                        impl Color {
                            // ... definitions of `new` and `white` ...
                            fn mix(&mut self, other: Color) {
                                self.r += other.r;
                                self.g += other.g;
                                self.b += other.b;
                            }
                        }

                        fn main() {
                            let mut color = Color::new(0, 0, 128);
                            color.mix(Color::white());
                            assert!(color.b == 255);
                        }
                    </code></pre>
                    <pre class="fragment current-visible" data-fragment-index="1" style="position:absolute; width: 100%"><code class="rust" data-trim style="max-height: 600px;">
                        struct Color {r: u8, g: u8, b: u8}

                        impl Color {
                            // ... definitions of `new` and `white` ...
                            fn mix(&mut self, other: Color) {
                                self.r = self.r.saturating_add(other.r);
                                self.g = self.g.saturating_add(other.g);
                                self.b = self.b.saturating_add(other.b);
                            }
                        }

                        fn main() {
                            let mut color = Color::new(0, 0, 128);
                            color.mix(Color::white());
                            assert!(color.b == 255);
                        }
                    </code></pre>
                    <pre class="fragment fade-in" data-fragment-index="2" style="position:absolute; width: 100%"><code class="rust" data-trim style="max-height: 600px;">
                        struct Color {r: u8, g: u8, b: u8}

                        impl Color {
                            // ... definitions of `new` and `white` ...
                            fn mix(&mut self, other: Color) {
                                *self = Color {
                                    r: self.r.saturating_add(other.r),
                                    g: self.g.saturating_add(other.g),
                                    b: self.b.saturating_add(other.b),
                                };
                            }
                        }

                        fn main() {
                            let mut color = Color::new(0, 0, 128);
                            color.mix(Color::white());
                            assert!(color.b == 255);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Panics in debug builds!
                        * `&amp;mut self` as `self` is allowed to change
                        * Last slide: ensure error when adding new entry to enum
                        * `*` operator: dereferencing. Often inferred.
                    </aside>
                </section>
                <section>
                    <h2>Generics and Traits</h2>
                    <ul>
                        <li>Generics: abstracting types</li>
                        <li>Traits: defining similar behaviors</li>
                    </ul>
                    <aside class="notes" data-markdown>
                        In C++/Java:
                        * Generics -> Templates
                        * Traits -> Interfaces
                    </aside>
                </section>
                <section>
                    <h2>Generic Data Types</h2>
                    <pre class="fragment fade-out" data-fragment-index="1" style="position:absolute; width:100%;"><code class="rust" data-trim style="max-height: 600px;">
                        struct ColorU8 {r: u8, g: u8, b: u8}

                        struct ColorU32 {r: u32, g: u32, b: u32}

                        struct ColorF32 {r: f32, g: f32, b: f32}
                    </code></pre>
                    <pre class="fragment fade-in" data-fragment-index="1" style="position:absolute;width:100%"><code class="rust" data-trim style="max-height: 600px;">
                        struct Color&lt;T> { r: T, g: T, b: T }

                        impl&lt;T> Color&lt;T> {
                            fn new(r: T, g: T, b: T) -> Color&lt;T> {
                                Color { r, g, b }
                            }
                        }

                        fn main() {
                            assert!(Color::new(0x00, 0x42, 0x00).g == 0x42);
                            assert!(Color::new(1, 2, 3u8).g == 2u8);
                            assert!(Color::new(0.2, 0.4, 1.0).r == 0.2);
                            // assert!(Color::new(0.2, 0.4, 1).r == 0.2);
                            //                              ^ expected floating-point
                            //                                number, found integer
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Many types of `Color`, eg for memory reasons
                        * `Color` is generic over some type `T`
                        * `T` can be only a single type per instantiation
                    </aside>
                </section>
                <section>
                    <h2>Generic Data Types</h2>
                    <pre><code class="rust" data-trim style="max-height: 600px;">
                        struct Color&lt;T> { r: T, g: T, b: T }
                        // definition of Color&lt;T>::new

                        fn intensity(c: &Color&lt;f32>) -> f32 {
                            (c.r + c.g + c.b) / 3.
                        }

                        fn main() {
                            let c: Color&lt;f32> = Color::new(0.2, 0.4, 0.);
                            assert!(intensity(&c) == 0.2);
                            assert!(Color::&lt;u32>::new(1, 2, 4).g == 2u32);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * `intensity` expects specific version of `Color`
                        * Compiler can infer `T`
                        * Expecitly calling in instantiation of a generic uses `::&lt;T>` syntax
                        * That syntax is called the turbofish
                    </aside>
                </section>
                <section>
                    <h2>Traits</h2>
                    <pre><code class="rust" data-trim style="max-height: 600px;">
                        struct Color {r: u8, g: u8, b: u8}
                        trait Mixable {
                            fn mix(&mut self, other: Self);
                        }

                        impl Mixable for Color {
                            fn mix(&mut self, other: Color) {
                                self.r += other.r; self.g += other.g;
                                self.b += other.b;
                            }
                        }

                        fn mix_with_green(col = )
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * `intensity` expects specific version of `Color`
                        * Compiler can infer `T`
                        * Expecitly calling in instantiation of a generic uses `::&lt;T>` syntax
                        * That syntax is called the turbofish
                    </aside>
                </section>
                <section>
                    <h2>Error Handling</h2>
                </section>
                <section>
                    <h2>Option</h2>
                    <pre><code class="rust" data-trim style="max-height: 600px;">
                        /// Option in core language
                        enum Option&lt;T> {
                            Some(T),
                            None,
                        }

                        // In the core language as: `a.checked_div(b)`.
                        fn safe_div(a: usize, b: usize) -> Option&lt;usize> {
                            if b != 0 {
                                Some(a / b)
                            } else {
                                None
                            }
                        }

                        fn main() {
                            assert!(safe_div(1, 0) == None);
                            assert!(safe_div(1, 2) == Some(0));
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * First generic: explain type AND specific instance
                    </aside>
                </section>
                <section>
                    <h2>Result</h2>
                    <pre><code class="rust" data-trim style="max-height: 600px;">
                        /// Result&lt;T, E> in core language
                        enum Result&lt;T, E> {
                            Ok(T),
                            Err(E),
                        }
                        #[derive(PartialEq)]
                        enum Error { DivByZero, HasRemainder(f32) }
                        fn non_rem_div(a: usize, b: usize) -> Result&lt;usize, Error> {
                            if b == 0 {
                                Err(Error::DivByZero)
                            } else if a % b == 0 {
                                Ok(a / b)
                            } else {
                                Err(Error::HasRemainder(a as f32 / b as f32))
                            }
                        }
                        fn main() {
                            assert!(non_rem_div(4, 2) == Ok(2));
                            assert!(non_rem_div(5, 0) == Err(Error::DivByZero));
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Contrived example.
                        * Create special error types to indicate what went wrong.
                        * Deriving `PartialEq`!
                    </aside>
                </section>
                <section>
                    <h2>Ownership</h2>
                    <ul>
                        <li>Smart Pointers: Box, Rc, Vec, String</li>
                        <li>Copying &amp; Moving</li>
                    </ul>
                </section>
                <section>
                    <h2>Box</h2>
                    <pre><code class="rust" data-trim style="max-height: 600px;">
                        fn first_hundred_ints() -> Box<[u32; 32]> {
                            let mut ints = Box::new([0; 32]);
                            for i in 0..32 {
                                ints[i as usize] = i;
                            }
                            return ints;
                        }

                        fn main() {
                            let many_nums = first_hundred_ints();
                            assert!(many_nums[5] == 5);
                            let more_nums = first_hundred_ints();
                            assert!(many_nums == more_nums);

                            use std::mem::{size_of, size_of_val};
                            assert!(size_of_val(&more_nums) == size_of::&lt;usize>());
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * 32 heap-allocated `u32`s
                        * Deallocated when falling out of scope
                        * Size on stack of `Box` is equal to size of a pointer
                    </aside>
                </section>
                <section>
                    <h2>Vec</h2>
                    <pre style="width: initial;"><code class="rust" data-trim style="max-height: 600px;">
                        fn first_n_ints(n: usize) -> Vec&lt;u32> {
                            let mut ints = Vec::new();
                            for i in 0..n {
                                ints.push(i);
                            }
                            return ints;
                        }

                        fn main() {
                            let mut five_ints = first_n_ints(5);
                            assert!(five_ints.len() == 5);
                            assert!(five_ints[4] == 4); //< Panics when out of bounds!
                            assert!(five_ints.get(5) == None);

                            five_ints.push(42);
                            assert!(five_ints.len() == 6);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * `Vec`: a contiguous growable array type
                        * Deallocated when falling out of scope
                        * Prefer using `Vec::get` to handle out of bounds
                        * How many length checks in release code? 1!
                    </aside>
                </section>
                <section style="width: 115%; left: -7.5%;">
                    <h2>Moving</h2>
                    <pre class="fragment fade-out" data-fragment-index="1" style="position:absolute; width: 100%;"><code class="rust" data-trim style="max-height: 600px;">
                        fn sum(ns: Box&lt;[u32]>) -> u32 {
                            let mut sum = 0;
                            for n in ns.iter() {
                                sum += n;
                            }
                            sum
                        }

                        fn main() {
                            let nums = Box::new([1, 2, 5, 8, 10]);
                            let s = sum(nums);
                            assert!(s == 26);
                        }
                    </code></pre>
                    <pre class="fragment current-visible" data-fragment-index="1" style="position:absolute; width: 100%;"><code class="rust" data-trim style="max-height: 600px;">
                        fn sum(ns: Box&lt;[u32]>) -> u32 {
                            let mut sum = 0;
                            for n in ns.iter() {
                                sum += n;
                            }
                            sum
                        }

                        fn main() {
                            let nums = Box::new([1, 2, 5, 8, 10]);
                            let s = sum(nums);
                            assert!(s == 26);

                            let nums2 = nums; //?
                        }
                    </code></pre>
                    <pre class="fragment current-visible" data-fragment-index="2" style="position:absolute; width: 100%;"><code class="rust" data-trim style="max-height: 600px;">
                        fn sum(ns: Box&lt;[u32]>) -> u32 {
                            let mut sum = 0;
                            for n in ns.iter() {
                                sum += n;
                            }
                            sum
                        }

                        fn main() {
                            let nums = Box::new([1, 2, 5, 8, 10]);
                            //  ---- move occurs because `nums` has type `std::boxed::Box<[u32; 5]>`,
                            //  which does not implement the `Copy` trait
                            let s = sum(nums);
                            //          ---- value moved here
                            assert!(s == 26);
                            let nums2 = nums;
                            //          ^^^^ value used here after move
                        }
                        // error[E0382]: use of moved value: `nums`
                    </code></pre>
                    <pre class="fragment current-visible" data-fragment-index="3" style="position:absolute; width: 100%;"><code class="rust" data-trim style="max-height: 600px;">
                        fn sum(ns: Box&lt;[u32]>) -> u32 {
                            let mut sum = 0;
                            for n in ns.iter() {
                                sum += n;
                            }
                            sum
                        }

                        fn main() {
                            let nums = Box::new([1, 2, 5, 8, 10]);
                            let s = sum(nums.clone());
                            assert!(s == 26);

                            let nums2 = nums;
                            // let s = sum(nums); //< Illegal!
                            assert!(sum(nums2) == 26);
                        }
                    </code></pre>
                    <pre class="fragment fade-in" data-fragment-index="4" style="position:absolute; width: 100%;"><code class="rust" data-trim style="max-height: 600px;">
                        fn sum(ns: &[u32]) -> u32 {
                            let mut sum = 0;
                            for n in ns.iter() {
                                sum += n;
                            }
                            sum
                        }

                        fn main() {
                            let nums = Box::new([1, 2, 5, 8, 10]);
                            let s = sum(nums.as_ref());
                            assert!(s == 26);

                            let nums2 = nums;
                            // let s = sum(nums.as_ref()); //< Illegal!
                            assert!(sum(nums2.as_ref()) == 26);
                        }
                    </code></pre>
                    <aside class="notes" data-markdown>
                        * Boxed array (fixed-size) to Boxed slice
                        * Box deallocated in sum!
                        * Using `nums` after `sum` call?
                    </aside>
                </section>
            </div>
        </div>

        <script src="reveal.js-3.6.0/lib/js/head.min.js"></script>
        <script src="reveal.js-3.6.0/js/reveal.js"></script>

        <script>
            // More info about config & dependencies:
            // - https://github.com/hakimel/reveal.js#configuration
            // - https://github.com/hakimel/reveal.js#dependencies
            Reveal.initialize({
                slideNumber: true,
                dependencies: [
                    { src: 'reveal.js-3.6.0/plugin/markdown/marked.js' },
                    { src: 'reveal.js-3.6.0/plugin/markdown/markdown.js' },
                    { src: 'reveal.js-3.6.0/plugin/notes/notes.js', async: true },
                    { src: 'reveal.js-3.6.0/plugin/highlight/highlight.js', async: true, callback: function() {
                        document.querySelectorAll('span>code').forEach((block) => {
                          hljs.highlightBlock(block);
                        });
                        document.querySelectorAll('.inline-code code').forEach((block) => {
                            hljs.highlightBlock(block);
                        });

                        hljs.configure({tabsReplace: '  '});
                        hljs.initHighlightingOnLoad();
                    } }
                ]
            });
        </script>
    </body>
</html>
